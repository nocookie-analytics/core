/* tslint:disable */
/* eslint-disable */
/**
 * No Cookie Analytics
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AggregateStat
 */
export interface AggregateStat {
    /**
     * 
     * @type {number}
     * @memberof AggregateStat
     */
    total_visits: number;
    /**
     * 
     * @type {string}
     * @memberof AggregateStat
     */
    value: string;
}
/**
 * 
 * @export
 * @interface AnalyticsData
 */
export interface AnalyticsData {
    /**
     * 
     * @type {string}
     * @memberof AnalyticsData
     */
    start: string;
    /**
     * 
     * @type {string}
     * @memberof AnalyticsData
     */
    end: string;
    /**
     * 
     * @type {PageViewStat}
     * @memberof AnalyticsData
     */
    pageviews?: PageViewStat;
    /**
     * 
     * @type {Array<AvgMetricPerDayStat>}
     * @memberof AnalyticsData
     */
    lcp_per_day?: Array<AvgMetricPerDayStat>;
    /**
     * 
     * @type {Array<AvgMetricPerDayStat>}
     * @memberof AnalyticsData
     */
    cls_per_day?: Array<AvgMetricPerDayStat>;
    /**
     * 
     * @type {Array<AvgMetricPerDayStat>}
     * @memberof AnalyticsData
     */
    fp_per_day?: Array<AvgMetricPerDayStat>;
    /**
     * 
     * @type {Array<AvgMetricPerDayStat>}
     * @memberof AnalyticsData
     */
    fid_per_day?: Array<AvgMetricPerDayStat>;
    /**
     * 
     * @type {Array<PageViewsPerDayStat>}
     * @memberof AnalyticsData
     */
    pageviews_per_day?: Array<PageViewsPerDayStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    browser_families?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    countries?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    os_families?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    device_families?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    referrer_mediums?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    referrer_names?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    utm_sources?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    utm_mediums?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    utm_campaigns?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    utm_terms?: Array<AggregateStat>;
    /**
     * 
     * @type {Array<AggregateStat>}
     * @memberof AnalyticsData
     */
    utm_contents?: Array<AggregateStat>;
}
/**
 * 
 * @export
 * @interface AvgMetricPerDayStat
 */
export interface AvgMetricPerDayStat {
    /**
     * 
     * @type {number}
     * @memberof AvgMetricPerDayStat
     */
    value: number;
    /**
     * 
     * @type {string}
     * @memberof AvgMetricPerDayStat
     */
    date: string;
}
/**
 * 
 * @export
 * @interface BodyCreateUserOpenApiV1UsersOpenPost
 */
export interface BodyCreateUserOpenApiV1UsersOpenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface BodyResetPasswordApiV1ResetPasswordPost
 */
export interface BodyResetPasswordApiV1ResetPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof BodyResetPasswordApiV1ResetPasswordPost
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof BodyResetPasswordApiV1ResetPasswordPost
     */
    new_password: string;
}
/**
 * 
 * @export
 * @interface BodyUpdateUserMeApiV1UsersMePut
 */
export interface BodyUpdateUserMeApiV1UsersMePut {
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    domain_name: string;
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface DomainCreate
 */
export interface DomainCreate {
    /**
     * 
     * @type {string}
     * @memberof DomainCreate
     */
    domain_name: string;
}
/**
 * 
 * @export
 * @interface DomainUpdate
 */
export interface DomainUpdate {
    /**
     * 
     * @type {string}
     * @memberof DomainUpdate
     */
    domain_name?: string;
}
/**
 * 
 * @export
 * @interface EventCreated
 */
export interface EventCreated {
    /**
     * 
     * @type {boolean}
     * @memberof EventCreated
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventCreated
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreated
     */
    pvid?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum EventType {
    PageView = 'page_view',
    Metric = 'metric',
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum MetricType {
    Lcp = 'lcp',
    Fid = 'fid',
    Fp = 'fp',
    Cls = 'cls',
    LcpFinal = 'lcpFinal'
}

/**
 * 
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     * 
     * @type {string}
     * @memberof Msg
     */
    msg: string;
}
/**
 * 
 * @export
 * @interface PageViewStat
 */
export interface PageViewStat {
    /**
     * 
     * @type {number}
     * @memberof PageViewStat
     */
    total_visits: number;
}
/**
 * 
 * @export
 * @interface PageViewsPerDayStat
 */
export interface PageViewsPerDayStat {
    /**
     * 
     * @type {number}
     * @memberof PageViewsPerDayStat
     */
    total_visits: number;
    /**
     * 
     * @type {string}
     * @memberof PageViewsPerDayStat
     */
    date: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    full_name?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Analytics
         * @param {string} domainName 
         * @param {any} include 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsApiV1AGet: async (domainName: string, include: any, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getAnalyticsApiV1AGet', 'domainName', domainName)
            // verify required parameter 'include' is not null or undefined
            assertParamExists('getAnalyticsApiV1AGet', 'include', include)
            const localVarPath = `/api/v1/a/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (domainName !== undefined) {
                localVarQueryParameter['domain_name'] = domainName;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Analytics
         * @param {string} domainName 
         * @param {any} include 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalyticsApiV1AGet(domainName: string, include: any, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyticsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsApiV1AGet(domainName, include, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Analytics
         * @param {string} domainName 
         * @param {any} include 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsApiV1AGet(domainName: string, include: any, start?: string, end?: string, options?: any): AxiosPromise<AnalyticsData> {
            return localVarFp.getAnalyticsApiV1AGet(domainName, include, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Get Analytics
     * @param {string} domainName 
     * @param {any} include 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getAnalyticsApiV1AGet(domainName: string, include: any, start?: string, end?: string, options?: any) {
        return AnalyticsApiFp(this.configuration).getAnalyticsApiV1AGet(domainName, include, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DomainsApi - axios parameter creator
 * @export
 */
export const DomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new domain.
         * @summary Create Domain
         * @param {DomainCreate} domainCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainApiV1DomainsPost: async (domainCreate: DomainCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainCreate' is not null or undefined
            assertParamExists('createDomainApiV1DomainsPost', 'domainCreate', domainCreate)
            const localVarPath = `/api/v1/domains/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an domain.
         * @summary Delete Domain
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainApiV1DomainsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomainApiV1DomainsIdDelete', 'id', id)
            const localVarPath = `/api/v1/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain by ID.
         * @summary Read Domain
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDomainApiV1DomainsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readDomainApiV1DomainsIdGet', 'id', id)
            const localVarPath = `/api/v1/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain by name.
         * @summary Read Domain By Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDomainByNameApiV1DomainsByNameNameGet: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('readDomainByNameApiV1DomainsByNameNameGet', 'name', name)
            const localVarPath = `/api/v1/domains/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve domains.
         * @summary Read Domains
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDomainsApiV1DomainsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/domains/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an domain.
         * @summary Update Domain
         * @param {number} id 
         * @param {DomainUpdate} domainUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainApiV1DomainsIdPut: async (id: number, domainUpdate: DomainUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainApiV1DomainsIdPut', 'id', id)
            // verify required parameter 'domainUpdate' is not null or undefined
            assertParamExists('updateDomainApiV1DomainsIdPut', 'domainUpdate', domainUpdate)
            const localVarPath = `/api/v1/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsApi - functional programming interface
 * @export
 */
export const DomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new domain.
         * @summary Create Domain
         * @param {DomainCreate} domainCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainApiV1DomainsPost(domainCreate: DomainCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainApiV1DomainsPost(domainCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an domain.
         * @summary Delete Domain
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainApiV1DomainsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainApiV1DomainsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get domain by ID.
         * @summary Read Domain
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDomainApiV1DomainsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDomainApiV1DomainsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get domain by name.
         * @summary Read Domain By Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDomainByNameApiV1DomainsByNameNameGet(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDomainByNameApiV1DomainsByNameNameGet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve domains.
         * @summary Read Domains
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDomainsApiV1DomainsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Domain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDomainsApiV1DomainsGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an domain.
         * @summary Update Domain
         * @param {number} id 
         * @param {DomainUpdate} domainUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainApiV1DomainsIdPut(id: number, domainUpdate: DomainUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainApiV1DomainsIdPut(id, domainUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainsApi - factory interface
 * @export
 */
export const DomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsApiFp(configuration)
    return {
        /**
         * Create new domain.
         * @summary Create Domain
         * @param {DomainCreate} domainCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainApiV1DomainsPost(domainCreate: DomainCreate, options?: any): AxiosPromise<Domain> {
            return localVarFp.createDomainApiV1DomainsPost(domainCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an domain.
         * @summary Delete Domain
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainApiV1DomainsIdDelete(id: number, options?: any): AxiosPromise<Domain> {
            return localVarFp.deleteDomainApiV1DomainsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain by ID.
         * @summary Read Domain
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDomainApiV1DomainsIdGet(id: number, options?: any): AxiosPromise<Domain> {
            return localVarFp.readDomainApiV1DomainsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain by name.
         * @summary Read Domain By Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDomainByNameApiV1DomainsByNameNameGet(name: string, options?: any): AxiosPromise<Domain> {
            return localVarFp.readDomainByNameApiV1DomainsByNameNameGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve domains.
         * @summary Read Domains
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDomainsApiV1DomainsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Domain>> {
            return localVarFp.readDomainsApiV1DomainsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an domain.
         * @summary Update Domain
         * @param {number} id 
         * @param {DomainUpdate} domainUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainApiV1DomainsIdPut(id: number, domainUpdate: DomainUpdate, options?: any): AxiosPromise<Domain> {
            return localVarFp.updateDomainApiV1DomainsIdPut(id, domainUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsApi - object-oriented interface
 * @export
 * @class DomainsApi
 * @extends {BaseAPI}
 */
export class DomainsApi extends BaseAPI {
    /**
     * Create new domain.
     * @summary Create Domain
     * @param {DomainCreate} domainCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public createDomainApiV1DomainsPost(domainCreate: DomainCreate, options?: any) {
        return DomainsApiFp(this.configuration).createDomainApiV1DomainsPost(domainCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an domain.
     * @summary Delete Domain
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public deleteDomainApiV1DomainsIdDelete(id: number, options?: any) {
        return DomainsApiFp(this.configuration).deleteDomainApiV1DomainsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain by ID.
     * @summary Read Domain
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public readDomainApiV1DomainsIdGet(id: number, options?: any) {
        return DomainsApiFp(this.configuration).readDomainApiV1DomainsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain by name.
     * @summary Read Domain By Name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public readDomainByNameApiV1DomainsByNameNameGet(name: string, options?: any) {
        return DomainsApiFp(this.configuration).readDomainByNameApiV1DomainsByNameNameGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve domains.
     * @summary Read Domains
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public readDomainsApiV1DomainsGet(skip?: number, limit?: number, options?: any) {
        return DomainsApiFp(this.configuration).readDomainsApiV1DomainsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an domain.
     * @summary Update Domain
     * @param {number} id 
     * @param {DomainUpdate} domainUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public updateDomainApiV1DomainsIdPut(id: number, domainUpdate: DomainUpdate, options?: any) {
        return DomainsApiFp(this.configuration).updateDomainApiV1DomainsIdPut(id, domainUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Report a new event.
         * @summary New Event
         * @param {string} url 
         * @param {EventType} [et] Event type
         * @param {string} [pt] Page title
         * @param {string} [pvid] Page view ID
         * @param {number} [psb] Page size bytes
         * @param {string} [tz] Timezone
         * @param {number} [tzo] Timezone offset
         * @param {string} [ref] Referrer
         * @param {number} [ttfb] Time to first-byte
         * @param {number} [tt] Total time
         * @param {number} [dt] Download time
         * @param {MetricType} [mn] Metric name
         * @param {number} [mv] Metric value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newEventApiV1EGet: async (url: string, et?: EventType, pt?: string, pvid?: string, psb?: number, tz?: string, tzo?: number, ref?: string, ttfb?: number, tt?: number, dt?: number, mn?: MetricType, mv?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('newEventApiV1EGet', 'url', url)
            const localVarPath = `/api/v1/e/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (et !== undefined) {
                localVarQueryParameter['et'] = et;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (pt !== undefined) {
                localVarQueryParameter['pt'] = pt;
            }

            if (pvid !== undefined) {
                localVarQueryParameter['pvid'] = pvid;
            }

            if (psb !== undefined) {
                localVarQueryParameter['psb'] = psb;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }

            if (tzo !== undefined) {
                localVarQueryParameter['tzo'] = tzo;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            if (ttfb !== undefined) {
                localVarQueryParameter['ttfb'] = ttfb;
            }

            if (tt !== undefined) {
                localVarQueryParameter['tt'] = tt;
            }

            if (dt !== undefined) {
                localVarQueryParameter['dt'] = dt;
            }

            if (mn !== undefined) {
                localVarQueryParameter['mn'] = mn;
            }

            if (mv !== undefined) {
                localVarQueryParameter['mv'] = mv;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Report a new event.
         * @summary New Event
         * @param {string} url 
         * @param {EventType} [et] Event type
         * @param {string} [pt] Page title
         * @param {string} [pvid] Page view ID
         * @param {number} [psb] Page size bytes
         * @param {string} [tz] Timezone
         * @param {number} [tzo] Timezone offset
         * @param {string} [ref] Referrer
         * @param {number} [ttfb] Time to first-byte
         * @param {number} [tt] Total time
         * @param {number} [dt] Download time
         * @param {MetricType} [mn] Metric name
         * @param {number} [mv] Metric value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newEventApiV1EGet(url: string, et?: EventType, pt?: string, pvid?: string, psb?: number, tz?: string, tzo?: number, ref?: string, ttfb?: number, tt?: number, dt?: number, mn?: MetricType, mv?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newEventApiV1EGet(url, et, pt, pvid, psb, tz, tzo, ref, ttfb, tt, dt, mn, mv, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Report a new event.
         * @summary New Event
         * @param {string} url 
         * @param {EventType} [et] Event type
         * @param {string} [pt] Page title
         * @param {string} [pvid] Page view ID
         * @param {number} [psb] Page size bytes
         * @param {string} [tz] Timezone
         * @param {number} [tzo] Timezone offset
         * @param {string} [ref] Referrer
         * @param {number} [ttfb] Time to first-byte
         * @param {number} [tt] Total time
         * @param {number} [dt] Download time
         * @param {MetricType} [mn] Metric name
         * @param {number} [mv] Metric value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newEventApiV1EGet(url: string, et?: EventType, pt?: string, pvid?: string, psb?: number, tz?: string, tzo?: number, ref?: string, ttfb?: number, tt?: number, dt?: number, mn?: MetricType, mv?: number, options?: any): AxiosPromise<EventCreated> {
            return localVarFp.newEventApiV1EGet(url, et, pt, pvid, psb, tz, tzo, ref, ttfb, tt, dt, mn, mv, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Report a new event.
     * @summary New Event
     * @param {string} url 
     * @param {EventType} [et] Event type
     * @param {string} [pt] Page title
     * @param {string} [pvid] Page view ID
     * @param {number} [psb] Page size bytes
     * @param {string} [tz] Timezone
     * @param {number} [tzo] Timezone offset
     * @param {string} [ref] Referrer
     * @param {number} [ttfb] Time to first-byte
     * @param {number} [tt] Total time
     * @param {number} [dt] Download time
     * @param {MetricType} [mn] Metric name
     * @param {number} [mv] Metric value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public newEventApiV1EGet(url: string, et?: EventType, pt?: string, pvid?: string, psb?: number, tz?: string, tzo?: number, ref?: string, ttfb?: number, tt?: number, dt?: number, mn?: MetricType, mv?: number, options?: any) {
        return EventsApiFp(this.configuration).newEventApiV1EGet(url, et, pt, pvid, psb, tz, tzo, ref, ttfb, tt, dt, mn, mv, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiV1LoginAccessTokenPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginAccessTokenApiV1LoginAccessTokenPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginAccessTokenApiV1LoginAccessTokenPost', 'password', password)
            const localVarPath = `/api/v1/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPasswordApiV1PasswordRecoveryEmailPost: async (email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('recoverPasswordApiV1PasswordRecoveryEmailPost', 'email', email)
            const localVarPath = `/api/v1/password-recovery/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiV1ResetPasswordPost: async (bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetPasswordApiV1ResetPasswordPost' is not null or undefined
            assertParamExists('resetPasswordApiV1ResetPasswordPost', 'bodyResetPasswordApiV1ResetPasswordPost', bodyResetPasswordApiV1ResetPasswordPost)
            const localVarPath = `/api/v1/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyResetPasswordApiV1ResetPasswordPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiV1LoginTestTokenPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/login/test-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPasswordApiV1PasswordRecoveryEmailPost(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testTokenApiV1LoginTestTokenPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testTokenApiV1LoginTestTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): AxiosPromise<Msg> {
            return localVarFp.recoverPasswordApiV1PasswordRecoveryEmailPost(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): AxiosPromise<Msg> {
            return localVarFp.resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiV1LoginTestTokenPost(options?: any): AxiosPromise<User> {
            return localVarFp.testTokenApiV1LoginTestTokenPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return LoginApiFp(this.configuration).loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password Recovery
     * @summary Recover Password
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any) {
        return LoginApiFp(this.configuration).recoverPasswordApiV1PasswordRecoveryEmailPost(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any) {
        return LoginApiFp(this.configuration).resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test access token
     * @summary Test Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public testTokenApiV1LoginTestTokenPost(options?: any) {
        return LoginApiFp(this.configuration).testTokenApiV1LoginTestTokenPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApiV1UsersPost: async (userCreate: UserCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUserApiV1UsersPost', 'userCreate', userCreate)
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiV1UsersOpenPost: async (bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserOpenApiV1UsersOpenPost' is not null or undefined
            assertParamExists('createUserOpenApiV1UsersOpenPost', 'bodyCreateUserOpenApiV1UsersOpenPost', bodyCreateUserOpenApiV1UsersOpenPost)
            const localVarPath = `/api/v1/users/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateUserOpenApiV1UsersOpenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserByIdApiV1UsersUserIdGet: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('readUserByIdApiV1UsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiV1UsersMeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersApiV1UsersGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApiV1UsersUserIdPut: async (userId: number, userUpdate: UserUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserApiV1UsersUserIdPut', 'userId', userId)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUserApiV1UsersUserIdPut', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiV1UsersMePut: async (bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateUserMeApiV1UsersMePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserApiV1UsersPost(userCreate: UserCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserApiV1UsersPost(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserByIdApiV1UsersUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMeApiV1UsersMeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserMeApiV1UsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsersApiV1UsersGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserApiV1UsersUserIdPut(userId, userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApiV1UsersPost(userCreate: UserCreate, options?: any): AxiosPromise<User> {
            return localVarFp.createUserApiV1UsersPost(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): AxiosPromise<User> {
            return localVarFp.createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): AxiosPromise<User> {
            return localVarFp.readUserByIdApiV1UsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiV1UsersMeGet(options?: any): AxiosPromise<User> {
            return localVarFp.readUserMeApiV1UsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.readUsersApiV1UsersGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserApiV1UsersUserIdPut(userId, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create new user.
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserApiV1UsersPost(userCreate: UserCreate, options?: any) {
        return UsersApiFp(this.configuration).createUserApiV1UsersPost(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new user without the need to be logged in.
     * @summary Create User Open
     * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any) {
        return UsersApiFp(this.configuration).createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific user by id.
     * @summary Read User By Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserByIdApiV1UsersUserIdGet(userId: number, options?: any) {
        return UsersApiFp(this.configuration).readUserByIdApiV1UsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserMeApiV1UsersMeGet(options?: any) {
        return UsersApiFp(this.configuration).readUserMeApiV1UsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users.
     * @summary Read Users
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).readUsersApiV1UsersGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update User
     * @param {number} userId 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any) {
        return UsersApiFp(this.configuration).updateUserApiV1UsersUserIdPut(userId, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any) {
        return UsersApiFp(this.configuration).updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(this.axios, this.basePath));
    }
}


